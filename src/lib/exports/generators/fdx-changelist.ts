import { BaseGenerator } from './base-generator'
import { ExportOptions, ExportResult } from '../export-service'

export class FDXChangelistGenerator extends BaseGenerator {
  async generate(script: any, options: ExportOptions): Promise<ExportResult> {
    const fdxContent = this.generateFDXChangelist(script)
    const filename = `changelist-${script.title.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}.fdx`
    return this.saveFile(fdxContent, filename, 'application/xml')
  }

  private generateFDXChangelist(script: any): string {
    const now = new Date()
    const timestamp = now.toISOString()

    // Group notes by page for easier reference
    const notesByPage = this.groupNotesByPage(script.notes || [])

    return `<?xml version="1.0" encoding="UTF-8"?>
<FinalDraft DocumentType="Script" Template="No" Version="12">
  <Content>
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`SCRIPTYBOY CHANGE LIST FOR: ${script.title}`)}</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`Generated: ${timestamp}`)}</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`Author: ${script.author}`)}</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>=====================================</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>

    ${this.generateSummarySection(script)}

    ${this.generateHighPriorityChanges(script.notes)}

    ${this.generatePageByPageChanges(notesByPage)}

    ${this.generateStructuralNotes(script)}

    ${this.generateRiskAssessment(script.riskFlags)}

    <Paragraph Type="Action">
      <Text>=====================================</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>END OF CHANGE LIST</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>${this.escapeXml('Generated by ScriptyBoy AI Analysis Platform')}</Text>
    </Paragraph>
  </Content>
</FinalDraft>`
  }

  private generateSummarySection(script: any): string {
    const notes = script.notes || []
    const highPriority = notes.filter((n: any) => n.severity === 'HIGH').length
    const mediumPriority = notes.filter((n: any) => n.severity === 'MEDIUM').length
    const lowPriority = notes.filter((n: any) => n.severity === 'LOW').length

    return `
    <Paragraph Type="Character">
      <Text>ANALYSIS SUMMARY</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`Total Notes: ${notes.length}`)}</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`High Priority: ${highPriority}`)}</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`Medium Priority: ${mediumPriority}`)}</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`Low Priority: ${lowPriority}`)}</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
    `
  }

  private generateHighPriorityChanges(notes: any[]): string {
    const highPriorityNotes = notes.filter(note => note.severity === 'HIGH')

    if (highPriorityNotes.length === 0) {
      return `
    <Paragraph Type="Character">
      <Text>HIGH PRIORITY CHANGES</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>No high priority issues identified.</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
      `
    }

    let section = `
    <Paragraph Type="Character">
      <Text>HIGH PRIORITY CHANGES</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>These issues should be addressed before proceeding:</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
    `

    highPriorityNotes.forEach((note, index) => {
      section += `
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`${index + 1}. ${note.area.replace('_', ' ')} Issue`)}</Text>
    </Paragraph>
      `

      if (note.page) {
        section += `
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`   Location: Page ${note.page}${note.lineRef ? `, Line ${note.lineRef}` : ''}`)}</Text>
    </Paragraph>
        `
      }

      if (note.excerpt) {
        section += `
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`   Current: "${note.excerpt}"`)}</Text>
    </Paragraph>
        `
      }

      if (note.suggestion) {
        section += `
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`   Suggestion: ${note.suggestion}`)}</Text>
    </Paragraph>
        `
      }

      section += `
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
      `
    })

    return section
  }

  private generatePageByPageChanges(notesByPage: Record<number, any[]>): string {
    const pages = Object.keys(notesByPage).map(Number).sort((a, b) => a - b)

    if (pages.length === 0) {
      return ''
    }

    let section = `
    <Paragraph Type="Character">
      <Text>PAGE-BY-PAGE NOTES</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
    `

    pages.forEach(page => {
      const pageNotes = notesByPage[page]
      section += `
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`PAGE ${page}:`)}</Text>
    </Paragraph>
      `

      pageNotes.forEach(note => {
        section += `
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`  • ${note.area.replace('_', ' ')} (${note.severity}): ${note.suggestion || 'See detailed notes'}`)}</Text>
    </Paragraph>
        `
      })

      section += `
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
      `
    })

    return section
  }

  private generateStructuralNotes(script: any): string {
    const structuralNotes = (script.notes || []).filter((note: any) =>
      ['STRUCTURE', 'PACING', 'CHARACTER'].includes(note.area)
    )

    if (structuralNotes.length === 0) {
      return ''
    }

    let section = `
    <Paragraph Type="Character">
      <Text>STRUCTURAL CONSIDERATIONS</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
    `

    const groupedStructural = this.groupNotesByArea(structuralNotes)

    Object.entries(groupedStructural).forEach(([area, areaNotes]) => {
      section += `
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`${area.replace('_', ' ')}:`)}</Text>
    </Paragraph>
      `

      ;(areaNotes as any[]).forEach(note => {
        section += `
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`  • ${note.suggestion || note.excerpt || 'Review required'}`)}</Text>
    </Paragraph>
        `
      })

      section += `
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
      `
    })

    return section
  }

  private generateRiskAssessment(riskFlags: any[]): string {
    if (!riskFlags || riskFlags.length === 0) {
      return ''
    }

    let section = `
    <Paragraph Type="Character">
      <Text>RISK ASSESSMENT</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>Potential production or distribution concerns:</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
    `

    riskFlags.forEach((risk, index) => {
      section += `
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`${index + 1}. ${risk.category.replace('_', ' ')} Risk (${risk.severity})`)}</Text>
    </Paragraph>
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`   ${risk.description}`)}</Text>
    </Paragraph>
      `

      if (risk.mitigation) {
        section += `
    <Paragraph Type="Action">
      <Text>${this.escapeXml(`   Mitigation: ${risk.mitigation}`)}</Text>
    </Paragraph>
        `
      }

      section += `
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>
      `
    })

    return section
  }

  private groupNotesByPage(notes: any[]): Record<number, any[]> {
    const grouped: Record<number, any[]> = {}

    notes.forEach(note => {
      if (note.page) {
        if (!grouped[note.page]) {
          grouped[note.page] = []
        }
        grouped[note.page].push(note)
      }
    })

    return grouped
  }

  private groupNotesByArea(notes: any[]): Record<string, any[]> {
    const grouped: Record<string, any[]> = {}

    notes.forEach(note => {
      const area = note.area || 'GENERAL'
      if (!grouped[area]) {
        grouped[area] = []
      }
      grouped[area].push(note)
    })

    return grouped
  }

  private escapeXml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;')
  }
}